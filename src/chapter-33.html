<article>
    <h1>#33. Get QA Involved Sooner <small>Unless you like broken software, that is</small></h1>

    <p>If you have a QA member or team in your programming group, you’re lucky. I know you may initially find that hard to believe. Doesn’t all the drama seem to come out of the programmer / QA relationship? At least in a few teams I’ve been on, this sadly has been the case. It’s too bad, too. They’re great members of the team. They’re needed.</p>

    <p>And, if you don’t have a QA team, let me just take a quick second to tell you to get one! If you can’t afford one in your budget, then take one of your programmers from a different project and have them act as QA temporarily. Of course, make sure to rotate this for each project so that one programmer doesn’t have to do QA all of the time. Using another programmer for QA is the least-worst “best” case compared to not having QA at all.</p>

    <p>I could ramble on about the importance of QA forever. Let’s move forward with the assumption that you now have QA staff available. Now, lets correct the next mistake that I’ve seen over and over. It’s time to stop putting QA at the end of the programming schedule.</p>

    <p>Programmers will insist, kicking and screaming, that projects can’t be tested until they have completely built the application. Sorry, but this is wrong. This objection happens for one of two reasons. First, it could be that the programmer hasn’t been disciplined to program features in a linear fashion. They may complete portions, get bored, and move on to another feature. This leaves most of the project completely broken until the last few minutes when everything comes together. How in the world could anyone test that? </p>

    <p>The other reason for this objection is because the programmer can’t figure out or imagine how someone could or would want to test a project that wasn’t completely finished. They might question when the newly created user authentication system should be tested. Should testing wait until the project is complete? What if he chooses to refactor something and break the user authentication. Won’t that make that whole testing scenario invalid? Don’t let this stop you from getting QA in earlier. Remember, this is just the programmer not understanding the concepts of QA. That’s fine, as much as programmers would like to think it, we can’t be masters of everything.</p>

    <p>The answers to these concerns and questions could take up a whole testing book so I won’t be diving into them now. That’s a topic for a testing based book. But suffice to say, with proper training and information, the arguments against getting QA sooner are void.</p>

    <p>Since we’ve squashed these two arguments, there is no other reason to put QA at the end of the programming task. QA should be involved sooner. QA should be involved immediately.</p>

    <p>When the project charter or definition has been finished, you would generally involve your programmers. Now, also involve QA. While the programmers are reviewing, estimating, and creating a task list, the QA resource will be doing the same thing. Instead of figuring out what classes to program and what languages are required to complete the task, QA will be working on developing use cases for the business as well as identifying potential areas to test/target for bugs. They should probably create their own test plan.</p>

    <p>Now, as soon as any feature is even remotely available to test, assign QA. QA should run through the wireframes as soon as possible or test the first draft of written code if no wireframes are available. Some teams function by a paradigm that requires the programmer to envision the solution for every request. Whatever the programmer thinks of is what will make up the final product. QA should just be plugged in to validate that the solution the programmer made doesn’t have any major bugs compared to his interpretation of the solution.</p>

    <p>But, that’s not the right approach. Instead, involve QA right away to validate that the programmer is making assumptions and creating things that make sense when compared to the documentation and project request. As individual features come out, QA tests them. This allows them to catch the bugs sooner and to perhaps deter a scenario where the rest of the application is built on a faulty assumption.</p>

    <p>Architecting your testing in this manner may require a test cases to be ran repeatedly at different parts of the project. If there is a large refactor, tests should be ran again. But, this is ok. The more testing, the better the product will be. Remember, the QA tester position is different than a programmer. The idea of repetition destroys a programmer’s world. A good QA resource understands the importance of their testing and comprehends that repetition is just part of the task they need to do. <span>(Hopefully QA has some automation tools at their disposal, though!)</span></p>

    <p>In the beginning of this chapter, I mentioned my experiences with drama between programmers and QA staff. This really happens. Think about it. As a programmer, you just put your heart and soul into some code. QA comes by and says “nope, doesn’t work” and sends it back. How dare they not understand and appreciate the work you’ve put in. You were even up late last night programming the feature they just rejected. At least acknowledge that most of it works! Or that it looks cool! Don’t be so cold or callous. <span>(Ok, so maybe you’re starting to see some of my diva programmer sneak out, but people do think like this!)</span> This piece of art <span>(if you will)</span> isn’t up to par according to QA. This can cause anger and anxiety.</p>

    <p>It’s even worse if you measure your programmer and QA performance on bugs created and bugs reported. You’ve immediately put them head-to-head in a battle to protect themselves and build their reputation, not to create better software. </p>

    <p>Now, let’s flip it around. Imagine this scenario: as a QA person, you test the signup process. You find three bugs and they’re fixed. Next, you move on to the forgot password section. You find one bug and that gets fixed. You are told that some of the code has been refactored, so you have to go back and test signup again. Ok, understood, so you go back and test again just to be sure. The same three bugs exist again! Oh, and now there’s a fourth one. What is wrong with the programmers? Don’t they get it? Don’t they use their software? You already reported these bugs, so why did their new programming allow these regressions? This type of scenario can be the cause of some of the ill will between the two teams too.</p>

    <p>Once again, I restate the solution to all of these problems. Bringing everyone together sooner. Keep the communication open. Don’t just put QA at the end making it a battle royale before the software is released.</p>

    <p>One interesting phenomenon I’ve noticed with some QA resources is the ownership they develop of the software increases dramatically the sooner they get involved. This is always a good thing. The more people who feel ownership in the project, the better the outcome of this project and the higher quality product released. I’ve personally seen QA resources defend the programmers and talk great about the product even in the face of a large bug report. Why? Because those QA people were brought in sooner, as project members, not towards the end as custodians.</p>

    <p>Want success with your QA team? Bring them in sooner. Make them get involved as soon as the programmers do. Keep lines of communication open. You’ll see greater ownership in the project and less animosity between the teams and those with potentially opposite responsibilities.</p>
</article>