<article>
    <h1>#6. Solve the Right Problem <small>Some great programmers don’t even need to code</small></h1>

    <p>Having programmers solve problems can be expensive. Telling them the wrong problem to solve can be even more expensive. </p>

    <p>I have a great example of this. At one place I worked, the project manager gave me a detailed requirements document. Well, that is strange! Rarely were the requirements this detailed. I was pretty excited to have this set of requirements, though. Perhaps with less guesswork, my job will be easier! As I paged through the document, however, I became a little bit concerned. The amount of work here was staggering.</p>

    <p>This project was requesting that I make changes to every single area of our system that interacted with a specific account number format. It required that each input, each validation, each sanity check and every service call be modified. This was quite a lot of work. I read through the document and estimated the amount of work like a good robot programmer. I gave the project manager back my quote. He was not happy.</p>

    <p>To solve this problem, I estimated it would take 2 programmers roughly 5 months to solve the problem. At our billable rate of $125 an hour for the 1680 combined hours, that was a bill of $210,000. As one might expect, the project managers and stakeholders asked if there was any way that I could shave any time off of that. That’s too much, they said. I asked for the requirements document back.</p>

    <p>By this time, I decided to start billing for my quoting and analyzing. It had taken me hours to give the first quote, which was rejected. I racked up another 6 hours <span>(at $125)</span> requoting and analyzing everything. Then it hit me: they had me solving the wrong problem.</p>

    <p>I asked for more detail about the account number problem. I had to go much deeper into the business to find out what the real problem was. It had to do with the way that certain accounts were created in the system. The chance of this particular scenario happening was as frequent as about 1 in 100. I suggested a safeguard against this particular process from happening. Instead of a programming patching the problem downstream, I suggested a process change to stop the flow at the origin. The only other necessity was a few checks and followup to make sure the new process was being applied properly.</p>

    <p>The stakeholders were amazed at my solution. Then, they took the time to figure out how much the process change would cost. They estimated they’d have to train the 15 data entry and administrative resources for about 2 hours. This cost was about $30 an hour. Then, they’d be able to do a few checks here and there to make sure the new process was being followed <span>(considered a negligible administrative cost)</span>. The total cost of this change was 30 hours at $30 an hour, plus my 6 hour estimate: $1,650. Not only was this hundreds of thousands of dollars cheaper, the total cost in dollars was so close to my total of hours estimate, it was funny. Basically, our team would have to work for a combined wage of $1 an hour to solve the problem within the same fiscal constraints.</p>

    <p>In this case, I looked at what the problem I was being asked to solve was, and decided that any programming solution wasn’t the best thing to do. I reframed the project to focus on a different problem with a different solution. </p>

    <p>Programming is not just about problem solving, it’s about deciding what problems to solve. In this case, the solution came to me after a second look and a period of analysis. However, an even better programmer may have been able to catch that even sooner. Figure out what problem actually needs to be solved, and solve that.</p>

    <p>Earlier in this this book, I related our programming jobs to customer service. Even with startups, we are customer service. We are serving the needs of someone. Another way to look at this is that we’re solving someone’s problems. In fact, when we’re not successful, it’s almost guaranteed that we’re solving the wrong problems. A great piece of software trying to solve a problem that isn’t needed or doesn’t exist only will be a great piece of software forever. It will never see full potential use. It’ll be a great piece of software, but never successful.</p>

    <p>Another way I look at this concept in programming is related to optimization. So many times we find ourselves trying to eke out the last little bit of performance from our software. Sometimes, it can be easy to go down a random rabbit hole and do something called premature optimization. That is, we invest in optimizations for problems that may not exist yet. We’re solving the wrong problem. Instead, look for the low hanging fruit and attack that. Solve the problem that needs to be solved, that is right in front of your face, and which has a solution that makes an impact.</p>

    <p>Want to be a great programmer? Just don’t solve problems - solve the right problems.</p>
</article>